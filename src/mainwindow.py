"""Define key components of main window"""


import os.path
from PIL import Image, ImageTk
import re
import tkinter as tk

from preferences import preferences
from utilities import is_mac


TEXT_WINDOW_ROW = 0
TEXT_WINDOW_COL = 0
IMAGE_WINDOW_ROW = TEXT_WINDOW_ROW
IMAGE_WINDOW_COL = 1
STATUSBAR_ROW = 1
STATUSBAR_COL = 0
STATUSBAR_COLSPAN = 2


class Root(tk.Tk):
    """Inherits from Tk root window"""

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.geometry("800x400")
        self.option_add("*tearOff", False)
        self.rowconfigure(0, weight=1)
        self.columnconfigure(0, weight=1)


class MainWindow:
    """Handles the construction of the main window with its basic widgets

    These class variables are set in ``__init__`` to store the single instance
    of these main window items. They are exposed externally via convenience
    functions with the same names, e.g. ``root()`` returns ``MainWindow.root``
    """

    root = None
    menubar = None
    maintext = None
    mainimage = None
    statusbar = None

    def __init__(self):
        MainWindow.root = Root()
        MainWindow.menubar = tk.Menu()
        root()["menu"] = menubar()

        frame = tk.Frame(root())
        frame.grid(column=0, row=0, sticky="NSEW", padx=5, pady=5)
        # Specify image window weights first, so text window will override if on same row or column
        frame.rowconfigure(IMAGE_WINDOW_ROW, weight=0)
        frame.columnconfigure(IMAGE_WINDOW_COL, weight=0)
        frame.rowconfigure(TEXT_WINDOW_ROW, weight=1)
        frame.columnconfigure(TEXT_WINDOW_COL, weight=1)

        MainWindow.statusbar = StatusBar(frame)
        statusbar().grid(
            column=STATUSBAR_COL,
            row=STATUSBAR_ROW,
            columnspan=STATUSBAR_COLSPAN,
            sticky="NSEW",
        )

        MainWindow.maintext = MainText(
            frame,
            undo=True,
            wrap="none",
            autoseparators=True,
            maxundo=-1,
        )

        maintext().grid(column=TEXT_WINDOW_COL, row=TEXT_WINDOW_ROW, sticky="NSEW")

        MainWindow.mainimage = MainImage(frame)
        if preferences.get("ImageWindow") == "Docked":
            mainimage().dock_image()
        else:
            mainimage().float_image()


class Menu(tk.Menu):
    """Extend ``tk.Menu`` to make adding buttons with accelerators simpler."""

    def __init__(self, parent, label, **kwargs):
        """Initialize menu and add to parent

        Args:
            parent: Parent menu/menubar, or another widget if context menu.
            label: Label string for menu, including tilde for keyboard
              navigation, e.g. "~File".
            **kwargs: Optional additional keywords args for ``tk.Menu``.
        """

        super().__init__(parent, **kwargs)
        command_args = {"menu": self}
        if label:
            (label_tilde, label_txt) = _process_label(label)
            command_args["label"] = (label_txt,)
            if label_tilde >= 0:
                command_args["underline"] = label_tilde
        # Only needs cascade if a child of menu/menubar, not if a context popup menu
        if isinstance(parent, tk.Menu):
            parent.add_cascade(command_args)

    def add_button(self, label, handler, accel=""):
        """Add a button to the menu.

        Args:
            label: Label string for button, including tilde for keyboard
              navigation, e.g. "~Save".
            handler: Callback function or built-in virtual event,
              e.g. "<<Cut>>", in which case button will generate that event.
            accel: String describing optional accelerator key, used when a
              callback function is passed in as ``handler``. Will be displayed
              on the button, and will be bound to the same action as the menu
              button. "Cmd/Ctrl" means `Cmd` key on Mac; `Ctrl` key on
              Windows/Linux.
        """
        (label_tilde, label_txt) = _process_label(label)
        (accel, key_event) = _process_accel(accel)
        if isinstance(handler, str):
            # Handler is built-in virtual event, so no key binding needed,
            # but event needs to be generated by button click
            def command(*args):
                root().focus_get().event_generate(handler)

        else:
            # Handler is function, so may need key binding
            command = handler
            if accel:
                maintext().key_bind(key_event, command)

        command_args = {
            "label": label_txt,
            "command": command,
            "accelerator": accel,
        }
        if label_tilde >= 0:
            command_args["underline"] = label_tilde
        self.add_command(command_args)

    def add_cut_copy_paste(self):
        """Add cut/copy/paste buttons to this menu"""
        self.add_button("Cu~t", "<<Cut>>", "Cmd/Ctrl+X")
        self.add_button("~Copy", "<<Copy>>", "Cmd/Ctrl+C")
        self.add_button("~Paste", "<<Paste>>", "Cmd/Ctrl+V")


def _process_label(label):
    """Given a button label string, e.g. "~Save...", where the optional
    tilde indicates the underline location for keyboard activation,
    return the tilde location (-1 if none), and the string without the tilde.
    """
    return (label.find("~"), label.replace("~", ""))


def _process_accel(accel):
    """Convert accelerator string, e.g. "Ctrl+X" to appropriate keyevent
    string for platform, e.g. "Control-X".

    "Cmd/Ctrl" means use ``Cmd`` key on Mac; ``Ctrl`` key on Windows/Linux.
    """
    if is_mac():
        accel = accel.replace("/Ctrl", "")
    else:
        accel = accel.replace("Cmd/", "")
    keyevent = accel.replace("Ctrl+", "Control-")
    keyevent = keyevent.replace("Shift+", "Shift-")
    keyevent = keyevent.replace("Cmd+", "Meta-")
    return (accel, f"<{keyevent}>")


class MainText(tk.Text):
    """MainText is the main text window, and inherits from ``tk.Text``."""

    def __init__(self, parent, **kwargs):
        """Create a Frame, and put a Text and two Scrollbars in the Frame.
        Layout and linking of the Scrollbars to the Text widget is done here.

        Args:
            parent: Parent widget to contain MainText.
            **kwargs: Optional additional keywords args for ``tk.Text``.
        """

        # Create surrounding Frame
        self.frame = tk.Frame(parent)
        self.frame.columnconfigure(0, weight=1)
        self.frame.rowconfigure(0, weight=1)

        # Create Text itself & place in Frame
        super().__init__(self.frame, **kwargs)
        tk.Text.grid(self, column=0, row=0, sticky="NSEW")

        # Create scrollbars, place in Frame, and link to Text
        hscroll = tk.Scrollbar(self.frame, orient=tk.HORIZONTAL, command=self.xview)
        hscroll.grid(column=0, row=1, sticky="EW")
        self["xscrollcommand"] = hscroll.set
        vscroll = tk.Scrollbar(self.frame, orient=tk.VERTICAL, command=self.yview)
        vscroll.grid(column=1, row=0, sticky="NS")
        self["yscrollcommand"] = vscroll.set

        # Set up response to text being modified
        self.modifiedCallbacks = []
        self.bind("<<Modified>>", self.modify_flag_changed_callback)

        self.init_context_menu()

    def grid(self, *args, **kwargs):
        """Override ``grid``, so placing MainText widget actually places surrounding Frame"""
        return self.frame.grid(*args, **kwargs)

    def key_bind(self, keyevent, handler):
        """Bind lower & uppercase versions of ``keyevent`` to ``handler``
        in main text window.

        If this is not done, then use of Caps Lock key causes confusing
        behavior, because pressing ``Ctrl`` and ``s`` sends ``Ctrl+S``.

        Args:
            keyevent: Key event to trigger call to ``handler``.
            handler: Callback function to be bound to ``keyevent``.
        """
        lk = re.sub("[A-Z]>$", lambda m: m.group(0).lower(), keyevent)
        uk = re.sub("[A-Z]>$", lambda m: m.group(0).upper(), keyevent)

        def handler_break(event, func):
            """In order for class binding not to be called after widget
            binding, event handler for widget needs to return "break"
            """
            func(event)
            return "break"

        self.bind(lk, lambda event: handler_break(event, handler))
        self.bind(uk, lambda event: handler_break(event, handler))

    #
    # Handle "modified" flag
    #
    def add_modified_callback(self, func):
        """Add callback function to a list of functions to be called when
        widget's modified flag changes.

        Args:
            func: Callback function to be added to list.
        """
        self.modifiedCallbacks.append(func)

    def modify_flag_changed_callback(self, *args):
        """This method is bound to <<Modified>> event which happens whenever
        the widget's modified flag is changed - not just when changed to True.

        Causes all functions registered via ``add_modified_callback`` to be called.
        """
        for func in self.modifiedCallbacks:
            func()

    def set_modified(self, mod):
        """Manually set widget's modified flag (may trigger call to
        ```modify_flag_changed_callback```).

        Args:
            mod: Boolean setting for widget's modified flag."""
        self.edit_modified(mod)

    def is_modified(self):
        """Return whether widget's text has been modified."""
        return self.edit_modified()

    def do_save(self, fname):
        """Save widget's text to file.

        Args:
            fname: Name of file to save text to.
        """
        with open(fname, "w", encoding="utf-8") as fh:
            fh.write(self.get(1.0, tk.END))
            self.set_modified(False)

    def do_open(self, fname):
        """Load text from file into widget.

        Args:
            fname: Name of file to load text from.
        """
        with open(fname, "r", encoding="utf-8") as fh:
            self.delete("1.0", tk.END)
            self.insert(tk.END, fh.read())
            self.set_modified(False)

    def init_context_menu(self):
        """Create a context menu for the main text widget"""

        menu_context = Menu(self, "")
        menu_context.add_cut_copy_paste()

        def post_context_menu(event):
            menu_context.post(event.x_root, event.y_root)

        if is_mac():
            self.bind("<2>", post_context_menu)
            self.bind("<Control-1>", post_context_menu)
        else:
            self.bind("<3>", post_context_menu)

    def get_image_filename(self):
        """Return the name of the image file for the page where the insert
        cursor is located.

        Returns:
            Name of the image file for the current page, or the empty string
            if unable to get image file name.
        """
        sep_index = self.search(
            "//-----File: ", self.get_insert_index(), backwards=True
        )
        if sep_index:
            return self.get(sep_index + "+13c", sep_index + "lineend").rstrip("-")
        else:
            return ""

    def get_insert_index(self):
        """Return index of the insert cursor."""
        return self.index(tk.INSERT)

    def set_insert_index(self, index, see=False):
        """Set the position of the insert cursor.

        Args:
            index: String containing index/mark to position cursor.
        """
        self.mark_set(tk.INSERT, index)
        if see:
            self.see(tk.INSERT)


class MainImage(tk.Frame):
    """MainImage is a frame, containing a label which can display a png/jpeg file.

    MainImage can be docked or floating."""

    def __init__(self, parent):
        """Create a label, defaulting to having no image loaded.

        Args:
            parent: Parent frame for when MainImage is docked.
        """
        super().__init__(parent, borderwidth=2, relief=tk.SUNKEN, name="*Image Viewer*")

        self.label = tk.Label(self, text="No image")
        self.label.grid(column=0, row=0)
        self.photo = None

    def load_image(self, filename=None):
        """Load or clear the given image file.

        Args:
            filename: Optional name of image file. If none given, clear image
              and display "No image" label.
        """
        if os.path.isfile(filename):
            image = Image.open(filename)
            width = 300
            scale = width / image.width
            height = image.height * scale
            image = image.resize((int(width), int(height)))

            self.photo = ImageTk.PhotoImage(image)
            self.label.config(image=self.photo)
        else:
            self.label.config(image="")

    def is_image_loaded(self):
        """Return if an image is currently loaded"""
        return bool(self.label.cget("image"))

    def float_image(self, *args):
        """Float the image into a separate window"""

        self.grid_remove()
        if self.is_image_loaded():
            root().wm_manage(self)
            self.lift()
            tk.Wm.protocol(self, "WM_DELETE_WINDOW", self.dock_image)
        else:
            root().wm_forget(self)
        preferences.set("ImageWindow", "Floated")

    def dock_image(self, *args):
        """Dock the image back back into the main window"""
        root().wm_forget(self)
        if self.is_image_loaded():
            self.grid(column=IMAGE_WINDOW_COL, row=IMAGE_WINDOW_ROW, sticky="NSEW")
        else:
            self.grid_remove()

        preferences.set("ImageWindow", "Docked")


class StatusBar(tk.Frame):
    """Statusbar at the bottom of the screen.

    Labels in statusbar can be automatically or manually updated.
    """

    def __init__(self, parent):
        """Initialize statusbar within given frame.

        Args:
            parent: Frame to contain status bar.
        """
        super().__init__(parent, borderwidth=1, relief=tk.SUNKEN)
        self.labels = {}
        self.callbacks = {}
        self._update()
        tk.Label(self)

    def add(self, key, callback=None, **kwargs):
        """Add label to status bar

        Args:
            key - Key to use to refer to label
            callback - Optional callback function that returns a string.
              If supplied, label will be regularly updated automatically with
              the string returned by ``callback()``. If argument not given,
              application is responsible for updating, using ``set(key)``.
        """
        kwargs["borderwidth"] = 1
        kwargs["relief"] = tk.RIDGE
        self.labels[key] = tk.Label(self, kwargs)
        self.callbacks[key] = callback
        self.labels[key].grid(column=len(self.labels), row=0)

    def set(self, key, value):
        """Set label in statusbar to given value.

        Args:
            key - Key to refer to label.
            value - String to use to update label.
        """
        self.labels[key].config(text=value)

    def _update(self):
        """Update labels in statusbar that have callbacks. Updates every
        200 milliseconds.
        """
        for key in self.labels:
            if self.callbacks[key]:
                self.set(key, self.callbacks[key]())
        self.after(200, self._update)


def root():
    """Return the single instance of Root"""
    return MainWindow.root


def mainimage():
    """Return the single MainImage widget"""
    return MainWindow.mainimage


def maintext():
    """Return the single MainText widget"""
    return MainWindow.maintext


def menubar():
    """Return the single Menu widget used as the menubar"""
    return MainWindow.menubar


def statusbar():
    """Return the single StatusBar widget"""
    return MainWindow.statusbar
